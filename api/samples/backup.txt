/**
 * Insert a new instruction to be executed by the application
 * newinstr : the new instruction
 * ilist : the instructions of the current block
 * instr : the reference instruction in the list -> newinstr is inserted just before instr
 */
static inline void translate_insert(instr_t* newinstr, instrlist_t* ilist, instr_t* instr)
{   
    instr_set_translation(newinstr, instr_get_app_pc(instr));
    instr_set_app(newinstr);
    instrlist_preinsert(ilist,instr, newinstr);
}

static void push_result_to_register(void* drcontext,instrlist_t *ilist, instr_t* instr, 
        bool removeInstr, bool is_double)
{
    if(instr && ilist && drcontext)
    {
        if(!removeInstr)
        {
            instr_t* copy = instr_clone(drcontext, instr);
            instr_set_translation(copy, instr_get_app_pc(instr));
            instr_set_app(copy);
            instrlist_preinsert(ilist,instr, copy);
        }
        
        reg_id_t reserved_reg;
        int num_dst = instr_num_dsts(instr);
        if(num_dst > 0)
        {
            opnd_t op, opDoF, op64, op_result_addr;
            reg_t reg;

            op = instr_get_dst(instr, 0);
            op_result_addr = opnd_create_rel_addr(*resultBuffer_ind , OPSZ_PTR);

            drreg_reserve_register(drcontext, ilist, instr, NULL, &reserved_reg);
            op64 = opnd_create_reg(reserved_reg);

            translate_insert(INSTR_CREATE_movq(drcontext, op64 , op_result_addr),ilist , instr);

            //opDoF = opnd_create_rel_addr(*resultBuffer_ind, is_double? OPSZ_8: OPSZ_4);
            opDoF = opnd_create_base_disp(opnd_get_reg(op64) , DR_REG_NULL , 0 , 0 , is_double ? OPSZ_8 : OPSZ_4);


//#ifdef SHOW_RESULTS
            dr_print_opnd(drcontext, STDERR, op, "DST : ");
            dr_print_opnd(drcontext, STDERR, opDoF, "RESULT : ");
//#endif
            if(opnd_is_reg(op))
            {
                reg = opnd_get_reg(op);
                if(reg_is_simd(reg)){ 
                    //SIMD scalar
                    dr_printf("SIMD scalar\n");
                    translate_insert(INSTR_CREATE_movsd(drcontext, op, opDoF), ilist, instr);
                    dr_printf("SIMD scalar after\n");
                }else if(reg_is_mmx(reg)){ 
                    //Intel MMX
                    dr_printf("MMX\n");
                    translate_insert(INSTR_CREATE_movq(drcontext, op, opDoF), ilist, instr);
                }else{ 
                    //General purpose register
                    dr_printf("GPR\n");
                    translate_insert(INSTR_CREATE_mov_ld(drcontext, op, opDoF), ilist, instr);
                }
                //TODO complete if necessary
            }else if(opnd_is_immed(op)){ // Immediate value
            
                dr_printf("immed\n");
                translate_insert(INSTR_CREATE_mov_imm(drcontext, op, opDoF), ilist, instr);
            }else if(opnd_is_memory_reference(op)){
                reg_id_t reserved_reg;
                dr_printf("memref\n");
                drreg_reserve_register(drcontext, ilist, instr, NULL, &reserved_reg);
                op64 = opnd_create_reg(reserved_reg);
                
                if(opnd_is_rel_addr(op))
                    dr_printf("reladdr\n");
                if(opnd_is_base_disp(op))
                    dr_printf("Basdisp\n");
                if(opnd_is_abs_addr(op))
                    dr_printf("absaddr\n");
                if(opnd_is_pc(op))
                    dr_printf("pc\n");
                
                translate_insert(INSTR_CREATE_movq(drcontext, op64, opDoF), ilist, instr);
                translate_insert(INSTR_CREATE_movq(drcontext, op, op64), ilist, instr);

                
            }
            drreg_unreserve_register(drcontext, ilist, instr, reserved_reg);
        }
        
        instrlist_remove(ilist, instr);
        instr_destroy(drcontext, instr);
    }
}

/* ***************************************************************************************************************************************** */

static void push_instr_to_doublebuffer(void *drcontext, instrlist_t *ilist, 
            instr_t* instr, bool is_double)
{
    if(instr && ilist && drcontext)
    {
        int num_src = instr_num_srcs(instr);
        
        opnd_t op, opDoF, op64, op_dbuffer_addr,op_dbuffer/*,opnd_temp*/;
        for(int i=0; i<num_src; i++) {
            op = instr_get_src(instr, i);
            dr_print_opnd(drcontext , STDOUT , op , "OP : ");

            op_dbuffer_addr = opnd_create_rel_addr(*dbuffer_ind , OPSZ_PTR);
            //dr_print_opnd(drcontext , STDOUT , op_dbuffer_addr , "OPND ADDRESS BUFFER : ");

            reg_id_t reserved_reg;
            drreg_reserve_register(drcontext, ilist, instr, NULL, &reserved_reg);
            op64 = opnd_create_reg(reserved_reg);

            // Move buffer address in reserved register
            translate_insert(INSTR_CREATE_movq(drcontext, op64 , op_dbuffer_addr),ilist , instr);

            dr_print_opnd(drcontext , STDOUT , op64 , "OPND OP64 : ");
            
            /*
            opnd_temp = opnd_create_rel_addr(&buffer_address_reg , OPSZ_PTR);
            translate_insert(INSTR_CREATE_movq(drcontext,opnd_temp, op64), ilist, instr);
            */

            opDoF = opnd_create_base_disp(opnd_get_reg(op64) , DR_REG_NULL , 0 , i*(is_double ? sizeof(double) : sizeof(float)) , is_double ? OPSZ_8 : OPSZ_4);

            dr_print_opnd(drcontext, STDOUT, op, "\nOP :");
            if(opnd_is_reg(op)) // Register
            {
                reg_t reg = opnd_get_reg(op);
                if(reg_is_simd(reg))
                { 
                    // SIMD scalar 
                    //translate_insert(INSTR_CREATE_movsd(drcontext,opDoF, op), ilist, instr);
                    translate_insert(INSTR_CREATE_movsd(drcontext,opDoF, op), ilist, instr);
                    dr_print_opnd(drcontext , STDOUT , opDoF , "OPDOF : ");
                    
                } else if(reg_is_mmx(reg)) {
                    // Intel MMX
                    translate_insert(INSTR_CREATE_movq(drcontext, opDoF, op), ilist, instr);
                } else { 
                    // General purpose register
                    translate_insert(INSTR_CREATE_movq(drcontext, opDoF, op), ilist, instr);
                }
                //TODO complete if necessary

            } else if(opnd_is_immed(op)) { // Immediate value
                translate_insert(INSTR_CREATE_mov_imm(drcontext, opDoF, op), ilist, instr);
            }else if(opnd_is_memory_reference(op)){
                //dr_printf("memref\n");
                //dr_printf("%s\n", get_register_name(reserved_reg));
                
                reg_id_t temp_reg;
                drreg_reserve_register(drcontext, ilist, instr, NULL, &temp_reg);
                opnd_t op_temp_reg = opnd_create_reg(temp_reg);
                dr_print_opnd(drcontext , STDOUT , op_temp_reg , "TEMP_REG : ");

                /*
                if(opnd_is_rel_addr(op))
                    dr_printf("reladdr\n");
                if(opnd_is_base_disp(op))
                    dr_printf("Basdisp\n");
                if(opnd_is_abs_addr(op))
                    dr_printf("absaddr\n");
                if(opnd_is_pc(op))
                    dr_printf("pc\n");
                */

                //dr_printf("base_disp");
                //This case needs special care because it's a memory address not accessible directly
                //We can't mov from adress to adress so we'll copy the content in a register, 
                //then copy the register to memory

                //translate_insert(INSTR_CREATE_movq(drcontext, op64, ), ilist, instr);
                dr_print_opnd(drcontext , STDOUT , opDoF , "OPDOF : ");
                translate_insert(INSTR_CREATE_movq(drcontext, op_temp_reg, op), ilist, instr);
                translate_insert(INSTR_CREATE_movq(drcontext, opDoF, op_temp_reg), ilist, instr);

                //translate_insert(INSTR_CREATE_pop(drcontext, op64), ilist, instr);
                drreg_unreserve_register(drcontext, ilist, instr, temp_reg); 
            }
            drreg_unreserve_register(drcontext, ilist, instr, reserved_reg);
        }  
    }
}