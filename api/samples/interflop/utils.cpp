#include "utils.hpp"

#include <iostream>
#include <algorithm>
#include <cctype>
#include "dr_api.h"
#include "symbol_config.hpp"
#include "analyse.hpp"

static const char* IFP_SYMBOL_FILE_HEADER = 
"# This file has been generated by the InterFLOP sample to hold symbols used by the given program.\n"
"# Only the symbols using floating point operations that we may instrument are listed\n"
"# You can use it as a whitelist, blacklist, and modify it as you wish.\n"
"# Comments start with the character \'#\'.\n"
"# Each line of this file holds a symbol in the following format : \n"
"#\n"
"#\t\t\tmodule!symbol\n"
"#\n"
"# Here, a module can designate an executable, a library file... as per DynamoRIO's standards.\n"
"# A name alone (without a \'!\') designates the whole module\n"
"# Note that the whole modules listed here don't mean the program used the whole module, but rather that that module was used\n"
"#\n";

static const char* IFP_HELP_STRING =
"InterFLOP sample for DynamoRIO : replaces the floating point operations with their equivalent in Monte Carlo arithmetics [Parker et al. 2000]\n" 
"Usage : drrun [drrun options] -c libinterflop.so [interflop options] -- programToInstrument [program arguments]\n"
"Interflop options :\n"
"\t -h\n\t --help\n\t Displays the current help, stops the program\n\n"
"\t -n\n\t --no-lookup \n\t\t(Default) Disables the lookup for the symbols, instruments every floating operation\n\n"
"\t -w [filename]\n\t --whitelist [filename] \n\t\tInstruments only the symbols present in the given file\n\n"
"\t -b [filename]\n\t --blacklist [filename] \n\t\tDisable the instrumentation for the symbols present in the given file\n\n"
"\t -g [filename]\n\t --generate [filename]\n\t Generates the list of symbols in the given program and writes it to the given file, doesn't instrument anything\n\n"
"\n";

static int log_level = 0;

static int error_count = 0;

//Current functionning mode of the client, defines the behavior
static interflop_client_mode_t interflop_client_mode = IFP_CLIENT_DEFAULT;

//Current functionning mode of the analysis, defines the behavior
static interflop_analyse_mode_t interflop_analyse_mode = IFP_ANALYSE_NEEDED;

void set_log_level(int level){
    log_level = level;
}

int get_log_level(){
    return log_level;
}

void print_help(){
    dr_printf(IFP_HELP_STRING);
}

void write_to_file_symbol_file_header(std::ofstream& output){
    output << IFP_SYMBOL_FILE_HEADER;
}

interflop_client_mode_t get_client_mode(){
    return interflop_client_mode;
}

void set_client_mode(interflop_client_mode_t mode){
    interflop_client_mode = mode;
}

interflop_analyse_mode_t get_analyse_mode(){
        return interflop_analyse_mode;
}

void set_analyse_mode(interflop_analyse_mode_t mode){
        interflop_analyse_mode = mode;
}

void inc_error(){
        error_count += 1;
}

bool is_number(const std::string& s){
    return !s.empty() && std::find_if(s.begin(), 
        s.end(), [](char c) { return !std::isdigit(c); }) == s.end();
}

static bool utils_argument_parser(const std::string arg, int *i, int argc, const char* argv[]){
    if(arg == "--debug" || arg == "-d"){
        if(get_log_level() < 1){
            set_log_level(1);
        }
    }else if(arg == "--help" || arg == "-h"){
        print_help();
        return true;
    }else if(arg == "--loglevel" || arg == "-l"){
        *i += 1;
        if(*i < argc){
            std::string level(argv[*i]);
            if(!is_number(level)){
                dr_fprintf(STDERR, 
                        "LOGLEVEL FAILURE : Couldn't change the loglevel to \"%s\"\n", 
                        argv[*i]);
                set_client_mode(IFP_CLIENT_HELP);
                return true;
            }
            if(get_log_level() < std::stoi(level)){
                set_log_level(std::stoi(level));
            }
        }else{
                dr_fprintf(STDERR, 
                        "NOT ENOUGH ARGUMENTS : Lacking the loglevel associated with \"%s\"\n", 
                        argv[*i - 1]);
                set_client_mode(IFP_CLIENT_HELP);
                return true;
        }
    }else{
        inc_error();
    }
    return false;
}

bool arguments_parser(int argc, const char* argv[]){
    for(int i = 1; i < argc; ++i){
                error_count = 0;
                std::string arg(argv[i]);
                if(utils_argument_parser(arg, &i, argc, argv)){
                        return true;
                }else if(symbol_argument_parser(arg, &i, argc, argv)){
                        return true;
                }else if(analyse_argument_parser(arg, &i, argc, argv)){
                        return true;
                }else if(error_count == UNKNOWN_ARGUMENT){
                        dr_fprintf(STDERR, 
                                "Unknown command line option\n");
                        return true;
        }
    }

        symbol_client_mode_manager();
        analyse_mode_manager();
        return false;
}